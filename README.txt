
Mouse Keyboard Pyramids (MKP)
The project is currently being developed on wikifactory.
https://wikifactory.com/@sergesclv/mouse-keyboard-pyramids 


 I think that this should be appreciated by those who have a problem with the keyboard taking up a lot of space on the table.
The main feature here is the keyboard itself. There is a long story, but in short, there could be no objections to the idea itself. The idea turned out to be brilliant. But the technology was not brought to the end, and the inertia of device manufacturers did not allow moving on.
Now I can say that I have completely completed the development. Instead of pressing keys, as on a regular keyboard, I tilt the tip of the pyramid. The tip moves with a finger towards the symbol that is depicted on one of the four sides of the pyramid. This saves a lot of space. I perfectly placed 60 symbols on 15 pyramids, each with an area of one square centimeter.
The bottom joysticks with one rod carry out all the functionality of the control keys. I wrote the Back. I did not specify a spacebar, probably everyone will guess that the right joystick should be pushed to the right. Of course, everyone can program this functionality as they want using a CC BY license, but it seems to me that my solution is not so bad either. For example, the combination Ctrl + Alt + Del is obtained if we move the right joystick to the dial 21:00 Alt, and the left joystick to 16:30, that is, the position between Ctrl and Del. That is, my keyboard is also good because instead of pressing two control keys, you can simply tilt the joystick between them.
However, these same joysticks can also be used like  as in a game console. You can program everything like that. Why not?

under the hood 

 But the electrical circuit itself was not as simple as it might seem at first. Commercially available four-way switches I immediately rejected because they are bulky, rough and not adapted to printing even small text. The flat contact matrix used in push-button phones seemed to be more reliable, but still more suitable for the keyboard for which it was created. I've seen a lot of problems getting the slope of the pyramids to show up on flat pins the way I want them to. 
I derived my Keyboard formulas from pyramids.
 The rigid body of the pyramid AND  a soft moving part  OR The rigid movable rod of the pyramid AND  a soft body. 
You can only choose one of the two options. I decided to use the second one. The soft pyramid is supported from the inside by a rigid rod. This rod tilts as the tip of the pyramid moves. The position of the rod is the signal. The signal is recognized by two independent types of sensors. The first type is the proven Cap-touch.  At the bottom of the device, the rod contacts and abuts against the plate. This is the top capacitor plate. Two lower plate capacitors for rows and columns. The 5x3 pyramid matrix gives the address of each of the 15 pyramids. But this rod, working as a mechanical lever, simultaneously moves a special plate at the bottom, passing through one of the 15 holes. This is a free plate along the X and Y axes. The direction of movement of the plate along the axes is monitored by two linear Hall sensors. In total, there are 6 linear Hall sensors on the motherboard. Here we have a device of three joysticks. Since the two lower joysticks have a similar circuit. The difference between a keyboard joystick and other joysticks is that it is simply larger, as 15 rods pass through it. I left large gaps and, accordingly, an idle for each rod. Thus, one rod, having passed its idle gap, can move the entire plate within the idle range of the remaining 14 rods. 
To determine the address of the pyramid through capacitive sensors, I decided to use Atmel AT42QT1481. Hall sensors are DRV5057-Q1 with PWM output, and magnets with a diameter of 2mm and a length of 5mm are attached to them. This gives a tracking sensitivity of less than 0.1mm. For mouse functionality, I found the PMW3360 sensor also offered for gaming. I decided to install not one mouse wheel in the center as usual, but two on the sides. It is simpler in terms of the mechanics themselves and saving internal space. These two wheels perform exactly the same scrolling function as one, with the only difference that using the wheel as a third key will become even easier and more convenient. You will not need to wring the wheel to the side, but simply click on the right wheel from above, as well as on the mouse button.
I also decided that I would take the Raspberry Pi Pico microcontroller. The microcontroller is placed in the back, where there is still enough space for additional modules. The length of the mouse-keyboard turned out to be 140 mm, which is comparable to the usual dimensions. In width, my device looks larger due to the tubular battery slots on the side. I decided to use four AA batteries, which gives always guaranteed 5-6 volts.

BOM  and development environment

I use a bunch of Freecad and KiCad, these are open development environments that anyone can install for themselves. Commercial environments are more powerful, and here I see mainly this toolkit presented, but for now I'm using what I have. Perhaps in the future it makes sense to switch to commercial CAD. 
I also use GitHub for version control, as this is probably the most familiar not only to me. Other commercial development environments, of course, have their own version control system, but here at this stage it seems to me that there is enough. 
Work on my device is not finished yet, and the potential, as it seems to me, is only at the beginning of development. I am enclosing a bill of materials in the datasheets folder. I also added the build tree there, as I think this will give additional clarity. It can be seen from the BOM that the entire device currently consists of 283 individual parts. But that's counting all the pins, fasteners and capacitor plates. There are only 44 parts with their own design so far. I haven't finished work on the battery pack yet. There is no particular need for this yet, since the first alpha prototype will be cable. A relatively large number of details should not create a feeling of complexity and high cost. A typical 101-key mechanical keyboard has probably a lot more detail given the design of each button. The membrane keyboard has fewer parts, but there are soft cables and connectors oriented towards hand assembly. I try to focus on robotic assembly. This means that I do not have soft cables and connectors for manual connection, and all installation can be done by vertical feed. But assembly should be just as easy to do by hand. I have an idea of four screws in the bottom cover. There are no more screw fasteners in the device. Everything is disassembled and assembled by hand.

Problems and tasks

I decided that it's not worth doing the full layout of the board until there is experimental data on the use of sensors. This question concerns mainly capacitive sensors, since there should not seem to be any problems with Hall sensors. I have a capacitive sensor connection scheme that is different from the usual one. This may work fine, or maybe something will go wrong, then you will have to additionally change the entire electrical circuit. I provided for this an additional output on each capacitive sensor. If in the current circuit we have one intermediate series capacitance, then when connected through this pin, the capacitive contact becomes direct. The initial version of the prototype involves creating not the entire device, but one module. This module is in the drawings, this is the main module  on which you can conduct all the research. Thus, the body of the device and the motherboard in the first prototype are not required, which will facilitate the initial work.
The device itself must also be registered to USB as a keyboard or mouse. That is, the proposed device for connecting via cable or wireless should be recognized by any device and application, respectively, exactly as a mouse and keyboard. At the same time receiving the highest priority. As for the software, there is ready-made software available for custom keyboards. Problems here may however arise with maps. Keyboard simulators offer a naturally familiar keyboard matrix with a conventional character layout. They can be changed a little, but the established design itself cannot be changed. Symbols such as #, @, $ have a combination with Shift in the code table. They don't have their own original codes. I didn't find them. This is the number key + shift code. I also set my Shift, but I have #, @, $ symbols entered in one click. And I'm just at a loss how to encode them now. Keyboards have their own codes. These are ancient codes. These codes appeared much earlier than ascii, this is such an archaic, but it is present everywhere. Keyboard drivers are everywhere. And although keyboards have changed over time, character codes have remained the same. Micro-python, CircuitPython, and other microcontroller implementations of Python have both mouse and keyboard HIDs. It seems there characters are entered quite normally. 

Contribute 
I chose CC BY  license
I don't even know what else to suggest. For now, any participation is welcome. It seems to me that you can even unexpectedly offer some of your own solutions that I had not even thought about before. The range of possibilities of my device is very wide, since the architecture is open enough. You can offer to develop the simplest budget option without batteries with one USB. That is, just a mouse, the size of a standard mouse, but with a keyboard. Or vice versa, install a whole Raspberry with Linux, turning the mouse into a full-fledged computer without a screen. The rear compartment involves the installation of various additional modules. The ESP32 fits perfectly in there, which will immediately give you the possibility of a wide variety of wireless connections.
But of course, at this stage, the task now is a prototype and R&D. It is necessary to estimate the cost of the prototype and find an interested manufacturer. Lab research can be done with remote collaboration if everyone has their own basic set of prototypes. Of course, it is more reasonable to organize a whole laboratory, but it seems that now there will be difficulties in this. I will describe in more detail the R&D for the tasks department. Interested here may be manufacturers of mouse and keyboards. It seems to me that mouse manufacturers will be more agile and open in understanding tasks. Manufacturers of custom keyboards are trying to organize closed clubs of fans of their own solutions. They are somewhat reminiscent of the iPhone, although it was the iPhone that, as you know, ruined all keypad mobile phones. And it turns out the task of manufacturers of various custom keyboards is to reject everything alien. The mouse, on the other hand, went through a very rapid evolution in a very short time, starting from mechanics and ending with a video camera. Keyboards have changed little in a hundred and fifty years. At least the same QWERTY remained.


